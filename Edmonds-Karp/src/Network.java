import java.io.IOException;import java.util.HashMap;import java.util.LinkedList;/** * @author Uwe + Damien + Arne *  */public class Network extends DiGraph {	ResidualGraph residualGraph;		// -- constructor --	public Network() {	}	/**	 * Searches for sources in the graph	 * 	 * @return All sources found in the graph	 */	public Node findSource() {		LinkedList<Node> sources = new LinkedList<Node>();		boolean isSource = true;		// source <-> no incoming edges		for (Node n : nodes.values()) {			isSource = true;			for (Node m : nodes.values()) {				if (!m.equals(n) && isConnected(m, n)) {					isSource = false;					break;				}			}			if (isSource)				sources.add(n);		}		// error handling		if (sources.size() == 0)			System.out.println("Found no source in network");		else if(sources.size() > 1)			System.out.println("Found more than one source in network");				return sources.getFirst();	}	/**	 * Searches the graph for sinks.	 * 	 * @return All sinks found in the graph	 */	public Node findSink() {		LinkedList<Node> sinks = new LinkedList<Node>();		// sink <-> no outgoing edges		for (Node n : nodes.values()) {			if (n.getOutgoingEdges().isEmpty())				sinks.add(n);		}		// error handling		if (sinks.size() == 0)			System.out.println("Found no sink in network");		else if(sinks.size() > 1)			System.out.println("Found more than one sink in network");		return sinks.getFirst();	}	/**	 * Computes the maximum flow over the network with the Edmonds-Karp	 * Algorithm	 * 	 * @returns Value of maximal flow	 */	public double edmondsKarp() {		//nicht fertig				/**		 * Edmonds-Karp Algorithmus:		 *  1. Faengt mit leerem Fluss f an. Der Fluss wird iterativ vergroessert.		 *  2. Unter allen Pfaden von s nach t im Restgraphen Gf wird ein Pfad p mit den wenigstens Kanten ausgesucht.		 *     (z.B. durch Breitensuche im Restgraphen)		 *  3. Bestimmt den kritischen Wert des Pfades p (kleinste Restkapazitaet der Kanten).		 *  4. Alle Kantengewichte des Gf entlang p werden zm diesen kritischen Wert verringert.		 *     (Der Fluss braucht dabei nicht explizit gespeichert zu werden. Alle Info sind im Gf.)		 */				/**		 * Pseudocode aus der VL:		 * Gf <- Restgraph von G fuer leeren Fluss f â‰¡ 0		 * while es gibt einen Pfad p von s nach t in Gf do		 * 		waehle Pfad p in Gf mit den wenigstens Kanten		 * 		cv <- min{ rc(e) | e liegt auf Pfad p }		 * 		//aktualiesiere Gf entlang p:		 * 		for all Knoten v, w mit v->w auf Pfad p in Gf		 * 			rc(v,w) <- rc(v,w) - cv		 * 			rc(w,v) <- rc(w,v) + cv		 * 		end		 * end		 */		// These methods find the source and sink in the network		Node source = findSource();		Node sink = findSink();				int startNodeId = source.getID();		int endNodeId = sink.getID();		// You can use this method to create a residual network		residualGraph = initializeResidualGraph();		// TODO: Your implementation here				LinkedList<Node> path = new LinkedList<Node>();		path = this.residualGraph.findAugmentingPath(startNodeId, endNodeId);				double flow = 0;				while(path.isEmpty() == false){			double minCap = this.residualGraph.findMinCapacity(path);			flow += minCap;			this.residualGraph.updateResidualCapacity(minCap, path);			path = this.residualGraph.findAugmentingPath(startNodeId, endNodeId);		}				return flow;	}	/**	 * Builds the residual graph to a flow graph	 * 	 * @return the residual graph to this flow graph	 */	public ResidualGraph initializeResidualGraph() {		ResidualGraph residualGraph = new ResidualGraph();		// adding nodes		for (int i = 0; i < nodes.values().size(); i++)			residualGraph.addNode();		// adding edges		for (Node n : nodes.values()) {			for (Edge e : n.getOutgoingEdges()) {				// Add forward edges with same capacity				residualGraph.addEdge(n.id, e.endNode.id, e.weight);				// Add backwards edge				residualGraph.addEdge(e.endNode.id, n.id, 0);			}		}		return residualGraph;	}}