import java.util.LinkedList;import java.util.List;import java.lang.RuntimeException;/** * The class <code>Node</code> implements a node in a network. *  * @author AlgoDat team */public class Atm {	public LinkedList<Integer> denominations;    /**	 * Initializes the banknote denominations available to the ATM	 *	 * @param name	 *            the drawn value in visualization	 **/	public Atm() {		// initialize list of available denominations		denominations = new LinkedList<Integer>();		//Add denominations in a sorted order, highest value first:		denominations.add(200);		denominations.add(100);		denominations.add(50);		denominations.add(20);		denominations.add(10);		denominations.add(5);	}	/**	 * Computes the the number of banknotes for each denomination	 * 	 * @param total	 *            Amount of money requested	 *            End point of this edge.	 * @return List<int> 	 *            Amount of banknotes for each denomination, 	 *            as a list in the same order as the list denominations	 *            Example: [0,1,0,0,0,0]: one 100EUR banknote	 */	public LinkedList<Integer> getDivision(int total) {		LinkedList<Integer> division = new LinkedList<Integer>();		//TODO: Implement this		//fertig		//		if(total == 0) { //Wenn kein Betrag da ist, gibt es auch keine Banknoten.//			division.add(0);//			division.add(0);//			division.add(0);//			division.add(0);//			division.add(0);//			division.add(0);			//			return division;//		}////		if(total % 5 != 0) throw new RuntimeException(); //Werfe Exception, wenn der gegebene Betrag sich nicht aus den gegebenen Banknoten zsm setzen kann.//		//		/**//		 * Die gesuchten Banknoten teilen den gegebenen Betrag mit Ergebnis > 1,//		 * die nicht gesuchten mit Ergebnis 0 (ca.).//		 * Das gerundete (int) Ergebnis in division hinzufuegen.//		 * Die gefundene Banknote von dem gegebenen Betrag abziehen, um weitere passende Banknoten zu finden (so lange der Betrag > 0 ist).//		 *///		//		while(total > 0) {//			for(int bn : this.denominations) {//				int gesbn = total/bn;//				division.add(gesbn);//				total -= bn*(total/bn);//			}//		}//		////		for(int i : division) {////			System.out.println(i);////		}//		//		return division;				/**		 * 2. Idee:		 * Fuer alle Banknoten:		 * 		Wenn der gegebene Betrag kleiner ist als die Banknote, dann fuege eine auf 0 gesetzte Variable hinzu.		 * 		So lange der gegebene Betrag groesser oder gleich ist als die Banknoten, setze die Variable, die hinzugefuegt wird, auf 1.		 * 			-> Die gefundene Banknote von dem gegebenen Betrag abziehen, um weitere passende Banknoten zu finden.		 */						if(total % 5 != 0) throw new RuntimeException(); //Werfe Exception, wenn der gegebene Betrag sich nicht aus den gegebenen Banknoten zsm setzen kann.		for(int i = 0; i < this.denominations.size(); i++) {			int bn = this.denominations.get(i);			int variable = 0;			while(total >= bn) {				variable++; //Warum fkt. der Test nicht mit "variable = 1"? Die Konsole gibt jedoch das richtige Ergebnis aus.				total -= bn;			}			division.add(variable);		}		//		for(int j : division) {//			System.out.println(j);//		}				return division;	}	}